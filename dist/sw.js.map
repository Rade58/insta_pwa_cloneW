{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/sw.js","webpack:///(webpack)/buildin/global.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","global","assets","serviceWorkerOption","assetsArray","concat","filter","url","test","librariesAndOther","self","addEventListener","ev","waitUntil","caches","open","then","static_cache","Promise","all","map","path","fetch","response","put","keys","cacheName","delete","request","requestsUrl","URL","allStaticAssetUrls","u","pathname","findUrl","respondWith","dynamic_cache","match","resp","clone","catch","headers","includes","st_cache","g","this","Function","e","window"],"mappings":"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","file":"sw.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","// I CAN USE ONE ADDITINAL GLABAL VARIABLE IN MY SERVICE WORKER FILE\n\n// VRIABLE IS CALLED \n\n//              global\n\n//  I CAN ACCESS PLUGIN SETTINGS \n// (WHEN SHE WAS INSTANTIATED IN CONFIG PRESET FILE) THROUGH                \n\n                        //       global.serviceWorkerOption\n\n// AND THROUGH          global.serviceWorkerOption.assets\n\n// I CAN USE MENTIONED TO ACCESS FILE PATHS OF MY PROJECT, AND CACHE THESE FILES        oninstal\n\nconst {assets} = global.serviceWorkerOption;        // assets IS ARRAY OF PATHS\n\n\n// FILTER '.map' FILES AND '.map.gzip' FILES FROM CACHING oninstal\n\nconst assetsArray = [].concat(assets).filter(function(url){\n    if(!(/\\.map(\\.gz)?$/.test(url))){\n        return url;\n    }\n})\n\n\nconst librariesAndOther = [                                 // ALSO THIS ARRAY CAN BE CONCATANATED WITH  assets ARRAY (BUT I'LL LEAVE IT LIKE THIS FOR NOW)\n    '/',                                                        // IF I DID THAT I WOULDN'T BE USING TWO for of STATEMENTS INSIDE oninstall HANDLER SCOPE\n    'https://fonts.googleapis.com/css?family=Roboto:400,700',\n    'https://fonts.googleapis.com/icon?family=Material+Icons',\n    'copied_assets/favicon.png'\n];\n\n\nconst STATIC_CACHE = 'static-cache-v0';\nconst DYNAMIC_CACHE = 'dynamic-cache-v0';\nconst ON_DEMAND_CACHE = 'on_demand_cache_v0'\n\nself.addEventListener('install', function(ev){\n    ev.waitUntil(\n        caches.open(STATIC_CACHE)\n        .then(function(static_cache){\n\n            /* let allStaticAssets = assetsArray.concat(librariesAndOther) */\n\n            return Promise.all(                 // I don't know if it's a requirement (because activation is on hold after first reload) \n                                                // but I did ensure that Promise is passed \n                assetsArray.concat(librariesAndOther).map(function(path){       // to Promise.all, when every static asset is cached\n                    return fetch(path)\n                    .then(function(response){\n                        return static_cache.put(path, response)\n                    })\n                })            \n            )\n        })\n    );\n})\n\n// SO BECAUSE OF PREVIOUS CODE, EVERYTHING THAT IS EMMITED INITIALLY WILL BE IN Cache STORAGE (BUT I DON'T REALLY NEED EVERYTHING EMMITED, ESSPECIALY JSON FILES WEBPACK EMMITS)\n                                                                                            // CORRECTION:   THESE JSON FILES ARE EMMITED BY WEBPACK DEV SERVER, SO IN PRODUCTION THEY\n                                                                                            //               WILL NOT EXIST\n\n// NOW DEFINING CLEARING OLD, OUTDATED CACHES         onactivate\n\nself.addEventListener('activate', function(ev){\n    ev.waitUntil(\n        caches.keys()\n        .then(function(keys){\n            Promise.all(\n                keys.map(function(cacheName){\n\n                    if(cacheName !== STATIC_CACHE && \n                    cacheName !== DYNAMIC_CACHE && \n                    cacheName !== ON_DEMAND_CACHE){\n                        \n                        return caches.delete(cacheName);\n\n                    }\n\n                })\n            )\n        })\n    )\n})\n\n\n// CREATING HELPER FUNCTION THAT WILL PROVIDE BOOLEAN true IN INTERCEPTED NETWORK REQUEST IS A\n// REQUEST FOR SOME ASSETS, WHOOS PATHS I PROVIDED (PARTICULARLY librariesAndOther Array I DECLARED IN oninstall SCOPE IS IMPORTAND FOR THIS)\n// ALSO IT CHECKS assets ARRAY TOO\n\n// WHY I PROVIDED THIS FUNCTION\n// BECAUSE I WANT TO SERVE THESE FILES AS QICK AS I CAN BECAUSE WHEN I INTERCEPT THEIR REQUEST\n// I KNOW THEY ARE ALREADY CACHED oninstall AND I CAN SERVE THEM AS QUICK AS I CAN\n\nconst findUrl = function(requestsUrl){\n\n    if(requestsUrl === '/'){return true;}   //     '/'    CAN CAUSE PROBLEMS WHEN USING IT WITH THIS CONSTRUCTOR:     new URL(requestsUrl) \n\n    const url = new URL(requestsUrl)\n\n    let allStaticAssetUrls = assetsArray.concat(librariesAndOther)\n\n    for(let u of allStaticAssetUrls){\n        if(url.pathname === u){\n            return true;\n        }else{\n            continue;\n        }\n    }\n\n    return false;\n}\n\n\n// INTERCEPTING NETWORK REQUEST (IT'S ALLOWED ONLY AFTER NEW SERVICE WORKER IS ACTIVATED) AND\n// AND CACHING DYNAMIC ASSETS       onfetch\n\nself.addEventListener('fetch', function(ev){\n\n    // FIRST LETS TAKE IN ACCOUNT SOME JSON DATA I WANT TO STORE IN IndexedDB\n    // I'LL DEFINE THAT LATER BUT I'LL DEFINE if STATEMENT, JUST FOR THAT ONE URL\n\n    const firebasePath = \"some posible path I'll provide after I create  backend data\";   // I WANT TO PROVIDE        'CACHE THEN NETWORK STRATEGY FOR THIS ASSET'\n\n    if(firebasePath === ev.request.url){\n\n    \n    }else if(findUrl(ev.request.url)){            // HELPER FUNCTION WILL PROVIDE INFORMATINO IF ASSETS IS ALREADY IN STATIC CACHE \n                                                    // SO I NEED TO LOOK FOR IT AND RETURNIND FRO MTHERE                                      \n        ev.respondWith(\n            self.caches.open(STATIC_CACHE)\n            .then(function(static_cache){\n                return static_cache.match(ev.request)     // AT THIS POINT AFTER NEW SERVICE WORKER ACTIVATES I CAN RELOAD THE PAGE\n                                                            // AND I CAN CHECK NETWORK REQUEST IN DEV TOOLS\n                                                            // TO SEE IF Responses ARE SERVED FROM CACHE\n            })\n        )\n\n    }else{     // NOTING IF FOUND IN STATIC CACHE, SO I NEED TO SEARCH IT IN DYNAMIC CACHE (BUT I THINK I DIDNT TAKE IN ACCOUND ON_DEMAND_CACHE) (I'LL FIX THIS SOME OTHER TIME)\n\n        // HERE I CAN DEFINE DYNAMIC CACHING WITHOUT ANY CHECKS IF INTERCEPTED NETWORK REQUEST IS ONE FOR THE\n        // STATIC ASSETS, BECAUSE I ALREDY DID METIONED\n\n        ev.respondWith(                                // THIS IS IMPORTAND FOR FONTS REQUESTED FROM OTHER DOMAINS BECAUSE THEY HAVE ADDITIONAL REQUEST FOR CSS FILES (@font-family RULES)\n\n            self.caches.open(DYNAMIC_CACHE)\n            .then(function(dynamic_cache){\n                return dynamic_cache.match(ev.request)\n                .then(function(response){\n                    \n                    if(response){           // IF Response IS FOUND INSIDE CACHE I CAN SERVE IT\n                        return response;\n                    }                       // IF NOT, I NEED TO FETCH FROM THE NETWORK\n                    \n                    return fetch(ev.request)\n                    .then(function(resp){\n                        \n                        if(resp){           // IF NETWORK IS AVAILABLE Response IS HERE\n                                            // I CAN CACHE HIS CLONE AND SERVE THE ORIGINAL\n                            dynamic_cache.put(ev.request, resp.clone());\n\n                            return resp;y\n\n                        }\n\n                    })\n                    .catch(function(){          // IF NOTHING IS FOUND I MUST PROVIDE FALLBACK\n                                                // THIS IS PARTICULARY IMPORTAND FOR PAGE THAT'S NOT FOUND IN CACHE\n                                                // AND THERE'S NO NETWORK TO FETCH IT\n\n                        if(ev.request.headers.get('accept').includes('text/html')){     // THIS CAN BE CONDITION ALSO          /\\.html$/.test(ev.request.url)\n                                                                                        // BUT THE CURRENT ONE IS BETTER, BECAUSE IT USES REQUESTS HEADER\n                            \n                            // TAKING FALLBACK PAGE FROM CACHE AND SERVING THAT PAGE\n\n                            return caches.open(STATIC_CACHE)\n                            .then(function(st_cache){\n                                return st_cache.match('/fallback_offline.html')   // THIS COUNTS ONLY IF THERE'S NO NETWORK\n                                /* .then(function(fallbackPageResponse){\n                                    return fallbackPageResponse;\n                                }) */\n                            })\n                        \n                        }\n\n                    })\n\n                })\n            })\n        \n        )\n    }\n\n})\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n"],"sourceRoot":""}